1.VBO，在GPU上开一块空间
	（1）获取VBO index
	（2）绑定VBO index
	（3）给VBO分配显存空间 传输数据
	（4）告诉shader数据解析方式
	（5）激活锚点

2.VAO（核心模式）
	（1）记录了VBO的锚点信息，若不记录，则只有唯一一个锚点，并且只会指向某一个VBO

3.shader
	（1）版本
	（2）in：接受的上一个阶段输入数据
	（3）out：向下个阶段输出的数据，in和out要相同
	（4）uniform：C++传入shader的变量，数量有限 与显卡厂商有关，若未使用则系统自动删除
	（5）main：计算逻辑
	（6）向量语法vecx：. + xyz (vec3,1.0)等
	（7）layout：锚定点

4.索引绘制
	（1）多个三角形顶点数据是重复的
	（2）虽然增加了索引空间，但一般顶点数据不止坐标，还有uv、texture等，这样索引的利用效率就极高
	（3）EBO存储索引信息

5.纹理坐标
	（1）0-1 纹理坐标UV，因为各图片长宽比例不同。u/v * 长/宽
	（2）Texture Wrapping：顶点uv坐标超过0-1范围。采取特殊方式
	（3）Texture filter：uv计算结果为小数，采取特殊方式（nearest，Bi-linear）glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEARSET)
	（4）uniform sampler2D、texture函数、texture锚点0-15

6.光照
	（1）物体会反色、吸收一定波段的颜色，眼睛接受的是反射的部分。物体颜色即反射光的百分比，即直接相乘
	（2）数学上的实现
	（3）phong模型：ambient环境光+diffuse漫反射+specular镜面反射（高光）
		漫反射：	
			拉伸变换，
	（4）分类：平行光(w=0一个向量)，点光源(w=1一个点，非线性衰减系数，三个系数取值为经验性)，聚光灯（LightDir、SpotDit、Phi、Theta）
	（5）游戏引擎内一般是动态生成shader代码

7.材质
	（1）物体对于某一种光的反射强度
	（2）材质与纹理：纹理（物体本身最基础的颜色），材质（物体对光的反射属性）

8.光照贴图
	（1）作为材质系数，省去光照计算
	（2）不同材质的表达，铁皮与木质
	（3）用贴图代替光照材质中的specular diffuse等参数

9.深度缓冲
	（1）输出在屏幕上的是每个Fragment着色后的像素值
	（2）每个Fragment都有MVP变换后的xyz，xy为NDC坐标，z就是-z轴深度值
	（3）深度值越大 离摄像机越远
	（4）记录深度值，比较
	（5）深度缓冲Buffer：初始化为MAX，取min，绘制min的Fragment
	（6）深度值zFighting：两个平面太接近，深度值无法有足够的精度，产生前后重叠效应。需要避免两模型太近或增加z-Buffer的精度到32位
	（7）模板测试缓存（遮罩）：

10.模板缓存（Stencil buffer）：
	（1）启用模板缓存写入功能
	（2）通过渲染物体对每个 Fragment对应的点进行模板数据写入
	（3）关闭模板缓存写入功能
	（4）渲染其他物体，但本次渲染是通过模板测试
	（5）glStencilFunc：①什么情况下通过模板测试；②对比的数据对象；③对比之前所有缓存内数据都要与对比数据&&
	（6）glStencilOp：①sfail：如果本Fragment模板测试没通过；②dpfail：如果本Fragment模板测试通过，深度测试没通过；③dppass：如果本Fragment都通过了
	（7）高光边缘（描边）：
		glStencilFunc(GL_ALWAYS, 1.0f, 0xFF);
		glStencilMask(0xFF);
		glStencilOp（GL_KEEP , GL_KEEP,GL_REPLACE

		采用正常的Shader
		渲染需要高光的物体

		glStencilFunc(GL_NOTEQUAL,1, 0xFF);
		glStencilMask(0x00);

		采用单色Shader
		将物体缩放1.05大小
		渲染需要高光的物体

		//重置
		glStencilMask(0xFF);
		glStencilFunc(GL_ALWAYS, 0, 0xFF);

11.Blending
	（1）插值的公式，alpha
	（2）

12.CullFace：
	（1）加速手段，定义前后里外，剔除看不见的面。
	（2）根据顶点绘制顺序，逆时针和顺时针区分正反

13.FrameBuffer：
	（1）帧缓存不是一块显存，是一个类似VAO的组织架构，包含很多附件（ColorBuffer、DepthBuffer、StencilBuffer等	）
	（2）一般我们都是默认用0号帧缓存进行渲染
	（3）后处理，离屏渲染
	（4）原则：至少绑定一个附件、至少有一个ColorBUffer、每个绑定的附件必须开辟内存、每个绑定的附件必须有相同的采样标准
	（5）各类buffer实现方法：①Texture；②RenerBuffer，独特的存储结构和流水线结构；③混合使用
	（6）FrameBuffer渲染流程：first pass（渲染至ColorBuffer）、second pass（后处理）
	（7）后处理：利用FrameBuffer特性，渲染到ColorBuffer组件，然后对渲染后Texture进行后处理


	